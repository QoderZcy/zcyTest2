# 安全加固指南

<cite>
**本文档中引用的文件**
- [SecurityConfig.java](file://src/main/java/com/photo/config/SecurityConfig.java)
- [SecurityProperties.java](file://src/main/java/com/photo/config/SecurityProperties.java)
- [SecurityUtils.java](file://src/main/java/com/photo/util/SecurityUtils.java)
- [application.yml](file://src/main/resources/application.yml)
- [PhotoController.java](file://src/main/java/com/photo/controller/PhotoController.java)
- [GlobalExceptionHandler.java](file://src/main/java/com/photo/exception/GlobalExceptionHandler.java)
- [SecurityUtilsTest.java](file://src/test/java/com/photo/util/SecurityUtilsTest.java)
</cite>

## 目录
1. [简介](#简介)
2. [JWT Token密钥更换](#jwt-token密钥更换)
3. [HTTPS传输层加密](#https传输层加密)
4. [防火墙规则配置](#防火墙规则配置)
5. [CORS跨域策略配置](#cors跨域策略配置)
6. [防盗链机制配置](#防盗链机制配置)
7. [Spring Security配置](#spring-security配置)
8. [安全工具类使用](#安全工具类使用)
9. [攻击防护最佳实践](#攻击防护最佳实践)
10. [密钥和证书管理](#密钥和证书管理)
11. [总结](#总结)

## 简介

本安全加固指南基于Photo Upload System项目的现有安全架构，提供了在生产环境中必须实施的安全措施。该系统采用Spring Boot框架构建，集成了Spring Security、JWT认证机制和多种安全防护措施。

## JWT Token密钥更换

### 当前配置分析

系统当前使用以下JWT配置：

```yaml
security:
  token:
    secret: your-secret-key-change-this-in-production
    expiration: 86400  # 24小时
```

### 密钥更换步骤

#### 1. 生成强随机密钥

```bash
# 使用Java生成强随机密钥
openssl rand -base64 64 | head -c 64
```

#### 2. 更新配置文件

修改`application.yml`中的密钥配置：

```yaml
security:
  token:
    secret: "您的新密钥字符串"
    expiration: 86400  # 24小时
```

#### 3. 代码层面的安全考虑

确保在`SecurityProperties.java`中正确加载配置：

```java
@Data
public static class TokenConfig {
    private String secret = "your-secret-key";  // 默认值
    private Long expiration = 86400L; // 24小时
}
```

#### 4. 密钥轮换策略

建议实施定期密钥轮换机制：

```java
// 在SecurityProperties中添加轮换时间戳
private Long lastRotationTimestamp;
private Integer rotationIntervalDays = 90; // 90天轮换一次
```

**段落来源**
- [application.yml](file://src/main/resources/application.yml#L120-L125)
- [SecurityProperties.java](file://src/main/java/com/photo/config/SecurityProperties.java#L35-L40)

## HTTPS传输层加密

### 服务器配置

#### 1. Tomcat HTTPS配置

在`application.yml`中配置HTTPS：

```yaml
server:
  port: 8443
  ssl:
    enabled: true
    key-store-type: PKCS12
    key-store: classpath:keystore.p12
    key-store-password: your-keystore-password
    key-alias: photo-upload
    client-auth: want  # 可选：双向认证
```

#### 2. Nginx反向代理配置

```nginx
server {
    listen 443 ssl http2;
    server_name your-domain.com;
    
    ssl_certificate /path/to/certificate.crt;
    ssl_certificate_key /path/to/private.key;
    
    # SSL配置优化
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512;
    ssl_prefer_server_ciphers off;
    
    # HSTS配置
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
    
    location / {
        proxy_pass http://localhost:8080;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
```

#### 3. 强制HTTPS重定向

```java
@Configuration
public class HttpsRedirectConfig {
    
    @Bean
    public WebMvcConfigurer httpsRedirectConfigurer() {
        return new WebMvcConfigurer() {
            @Override
            public void configureWebRequest(WebRequestInterceptorRegistry registry) {
                registry.addInterceptor(new RequestInterceptor());
            }
        };
    }
    
    public static class RequestInterceptor implements HandlerInterceptor {
        @Override
        public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
            if (!request.isSecure()) {
                try {
                    String redirectUrl = "https://" + request.getServerName() + 
                                       ":443" + request.getRequestURI();
                    response.sendRedirect(redirectUrl);
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return true;
        }
    }
}
```

## 防火墙规则配置

### Linux防火墙配置

#### 1. iptables规则

```bash
# 允许SSH连接
sudo iptables -A INPUT -p tcp --dport 22 -j ACCEPT

# 允许HTTP和HTTPS流量
sudo iptables -A INPUT -p tcp --dport 80 -j ACCEPT
sudo iptables -A INPUT -p tcp --dport 443 -j ACCEPT

# 允许应用服务端口
sudo iptables -A INPUT -p tcp --dport 8080 -j ACCEPT

# 拒绝所有其他入站连接
sudo iptables -P INPUT DROP

# 允许出站连接
sudo iptables -P OUTPUT ACCEPT

# 保存规则
sudo iptables-save > /etc/iptables/rules.v4
```

#### 2. ufw防火墙配置

```bash
# 启用ufw
sudo ufw enable

# 允许SSH
sudo ufw allow ssh

# 允许HTTP/HTTPS
sudo ufw allow 80/tcp
sudo ufw allow 443/tcp

# 允许应用端口
sudo ufw allow 8080/tcp

# 设置默认拒绝策略
sudo ufw default deny incoming
```

### Docker容器防火墙

```dockerfile
FROM openjdk:17-jdk-slim

# 创建非root用户
RUN groupadd -r photouser && useradd -r -g photouser photouser

# 设置工作目录
WORKDIR /app

# 复制应用文件
COPY target/photo-upload-system.jar app.jar

# 更改文件所有权
RUN chown -R photouser:photouser /app

# 切换到非root用户
USER photouser

# 暴露应用端口
EXPOSE 8080

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:8080/health || exit 1

# 启动应用
CMD ["java", "-jar", "app.jar"]
```

## CORS跨域策略配置

### 当前CORS配置

系统已配置基本的CORS策略：

```yaml
security:
  cors:
    enabled: true
    allowed-origins:
      - http://localhost:3000
      - http://localhost:8080
    allowed-methods:
      - GET
      - POST
      - PUT
      - DELETE
    allowed-headers:
      - "*"
    allow-credentials: true
```

### 生产环境CORS配置

#### 1. 严格限制允许的域名

```yaml
security:
  cors:
    enabled: true
    allowed-origins:
      - https://yourdomain.com
      - https://app.yourdomain.com
      - https://cdn.yourdomain.com
    allowed-methods:
      - GET
      - POST
    allowed-headers:
      - Authorization
      - Content-Type
      - X-Requested-With
    allow-credentials: false  # 生产环境建议禁用
```

#### 2. 动态CORS配置

```java
@Bean
public CorsConfigurationSource corsConfigurationSource() {
    CorsConfiguration configuration = new CorsConfiguration();
    
    // 动态设置允许的域名
    configuration.setAllowedOrigins(getAllowedOrigins());
    configuration.setAllowedMethods(Arrays.asList("GET", "POST"));
    configuration.setAllowedHeaders(Arrays.asList(
        "Authorization", "Content-Type", "X-Requested-With"
    ));
    configuration.setAllowCredentials(false);
    
    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
    source.registerCorsConfiguration("/**", configuration);
    return source;
}

private List<String> getAllowedOrigins() {
    // 从配置文件动态加载
    return securityProperties.getCors().getAllowedOrigins();
}
```

**段落来源**
- [SecurityConfig.java](file://src/main/java/com/photo/config/SecurityConfig.java#L45-L55)
- [application.yml](file://src/main/resources/application.yml#L130-L140)

## 防盗链机制配置

### 当前防盗链配置

系统已实现基础的Referer验证：

```yaml
security:
  referer:
    enabled: true
    allowed-domains:
      - localhost
      - 127.0.0.1
```

### 生产环境防盗链配置

#### 1. 扩展允许的域名列表

```yaml
security:
  referer:
    enabled: true
    allowed-domains:
      - https://yourdomain.com
      - https://www.yourdomain.com
      - https://app.yourdomain.com
      - https://admin.yourdomain.com
      - https://cdn.yourdomain.com
```

#### 2. 实现Referer验证逻辑

```java
@Component
public class RefererValidator {
    
    private final List<String> allowedDomains;
    
    public RefererValidator(SecurityProperties securityProperties) {
        this.allowedDomains = securityProperties.getReferer().getAllowedDomains();
    }
    
    public boolean validate(HttpServletRequest request) {
        String referer = request.getHeader("Referer");
        
        // 如果没有Referer，允许直接访问(可根据需求调整)
        if (!StringUtils.hasText(referer)) {
            return true;
        }
        
        // 检查Referer是否在允许列表中
        return allowedDomains.stream()
            .anyMatch(domain -> referer.contains(domain));
    }
}
```

#### 3. 在控制器中使用防盗链验证

```java
@GetMapping("/view/{filename:.+}")
public ResponseEntity<byte[]> viewPhoto(@PathVariable String filename, 
                                       HttpServletRequest request) {
    
    // 防盗链检查
    if (securityProperties.getReferer().getEnabled()) {
        if (!refererValidator.validate(request)) {
            throw new AccessDeniedException("非法访问来源");
        }
    }
    
    // 继续处理请求...
}
```

**段落来源**
- [SecurityUtils.java](file://src/main/java/com/photo/util/SecurityUtils.java#L55-L70)
- [PhotoController.java](file://src/main/java/com/photo/controller/PhotoController.java#L95-L105)

## Spring Security配置

### 当前安全配置分析

系统使用Spring Security进行基础安全控制：

```java
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http
        .csrf(csrf -> csrf.disable())
        .cors(cors -> cors.configurationSource(corsConfigurationSource()))
        .sessionManagement(session -> 
            session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
        .authorizeHttpRequests(auth -> auth
            .requestMatchers(
                "/h2-console/**",
                "/api-docs/**",
                "/swagger-ui/**",
                "/swagger-ui.html",
                "/photos/view/**",
                "/photos/download/**",
                "/photos/public/**"
            ).permitAll()
            .anyRequest().permitAll()
        )
        .headers(headers -> headers.frameOptions(frame -> frame.disable()));
    
    return http.build();
}
```

### 生产环境安全配置增强

#### 1. 启用CSRF保护

```java
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http
        .csrf(csrf -> csrf.ignoringRequestMatchers(
            "/photos/**", "/api-docs/**", "/swagger-ui/**"
        ))
        .cors(cors -> cors.configurationSource(corsConfigurationSource()))
        .sessionManagement(session -> 
            session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
        .authorizeHttpRequests(auth -> auth
            .requestMatchers(
                "/h2-console/**",
                "/api-docs/**",
                "/swagger-ui/**",
                "/swagger-ui.html"
            ).permitAll()
            .anyRequest().authenticated()  // 所有其他请求都需要认证
        );
    
    return http.build();
}
```

#### 2. 添加JWT认证过滤器

```java
@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, 
                                  HttpServletResponse response, 
                                  FilterChain filterChain) 
                                  throws ServletException, IOException {
        
        String token = getTokenFromRequest(request);
        
        if (token != null && jwtService.validateToken(token)) {
            String username = jwtService.getUsernameFromToken(token);
            UsernamePasswordAuthenticationToken authentication = 
                new UsernamePasswordAuthenticationToken(username, null, 
                    Collections.emptyList());
            authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
            SecurityContextHolder.getContext().setAuthentication(authentication);
        }
        
        filterChain.doFilter(request, response);
    }
}
```

#### 3. 角色基础访问控制

```java
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http
        .authorizeHttpRequests(auth -> auth
            .requestMatchers("/admin/**").hasRole("ADMIN")
            .requestMatchers("/user/**").hasAnyRole("USER", "ADMIN")
            .requestMatchers("/photos/upload").authenticated()
            .requestMatchers("/photos/**").permitAll()
        );
}
```

**段落来源**
- [SecurityConfig.java](file://src/main/java/com/photo/config/SecurityConfig.java#L25-L45)

## 安全工具类使用

### XSS防护

系统已实现HTML实体编码防护：

```java
public static String cleanXSS(String value) {
    if (!StringUtils.hasText(value)) {
        return value;
    }
    return HtmlUtils.htmlEscape(value);
}
```

#### 生产环境增强XSS防护

```java
public static String cleanXSS(String value) {
    if (!StringUtils.hasText(value)) {
        return value;
    }
    
    // 多层次防护
    String result = HtmlUtils.htmlEscape(value);
    
    // 移除JavaScript事件处理器
    result = result.replaceAll("(?i)javascript:", "");
    result = result.replaceAll("(?i)on\\w+=", "");
    
    // 移除危险标签
    result = result.replaceAll("(?i)<script[^>]*>.*?</script>", "");
    
    return result;
}
```

### SQL注入防护

系统实现了简单的SQL注入字符过滤：

```java
public static String cleanSQLInjection(String value) {
    if (!StringUtils.hasText(value)) {
        return value;
    }
    
    String[] dangerousChars = {"'", "\"", ";", "--", "/*", "*/", 
                              "xp_", "sp_", "exec", "execute", 
                              "select", "insert", "update", "delete", 
                              "drop", "create", "alter"};
    String result = value;
    for (String ch : dangerousChars) {
        result = result.replaceAll("(?i)" + ch, "");
    }
    return result;
}
```

#### ORM框架使用

推荐使用ORM框架的参数化查询：

```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    @Query("SELECT u FROM User u WHERE u.username = :username AND u.active = true")
    Optional<User> findByUsernameActive(@Param("username") String username);
}
```

### 路径遍历攻击防护

系统已实现路径遍历检测：

```java
public static boolean isPathTraversal(String path) {
    if (!StringUtils.hasText(path)) {
        return false;
    }
    
    List<String> dangerousPatterns = Arrays.asList("..", "./", ".\\", 
                                                 "%2e%2e", "%252e%252e");
    for (String pattern : dangerousPatterns) {
        if (path.toLowerCase().contains(pattern)) {
            log.warn("检测到路径遍历攻击: {}", path);
            return true;
        }
    }
    return false;
}
```

**段落来源**
- [SecurityUtils.java](file://src/main/java/com/photo/util/SecurityUtils.java#L20-L25)
- [SecurityUtils.java](file://src/main/java/com/photo/util/SecurityUtils.java#L115-L135)
- [SecurityUtils.java](file://src/main/java/com/photo/util/SecurityUtils.java#L85-L105)

## 攻击防护最佳实践

### XSS攻击防护

#### 1. 内容安全策略(CSP)

```yaml
server:
  tomcat:
    additional-tomcat-config:
      csp-header: "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline';"
```

#### 2. 输入验证和输出编码

```java
@PostMapping("/comment")
public ResponseEntity<?> addComment(@RequestBody @Valid CommentRequest request) {
    // 输入验证
    String cleanedContent = SecurityUtils.cleanXSS(request.getContent());
    
    // 输出编码
    Comment comment = new Comment();
    comment.setContent(HtmlUtils.htmlEscape(cleanedContent));
    
    return commentService.save(comment);
}
```

### SQL注入防护

#### 1. 使用JPA Repository

```java
@Repository
public interface PhotoRepository extends JpaRepository<Photo, Long> {
    List<Photo> findByUserIdAndIsPublic(String userId, boolean isPublic);
    
    @Query("SELECT p FROM Photo p WHERE p.userId = :userId AND p.isPublic = true")
    List<Photo> findPublicPhotosByUserId(@Param("userId") String userId);
}
```

#### 2. 参数化查询

```java
public List<Photo> searchPhotos(String keyword, String userId) {
    String sql = "SELECT * FROM photos WHERE (title LIKE :keyword OR description LIKE :keyword) " +
                 "AND user_id = :userId AND is_public = true";
    
    return entityManager.createNativeQuery(sql, Photo.class)
        .setParameter("keyword", "%" + keyword + "%")
        .setParameter("userId", userId)
        .getResultList();
}
```

### 路径遍历攻击防护

#### 1. 文件访问权限验证

```java
@GetMapping("/download/{filename:.+}")
public ResponseEntity<byte[]> downloadPhoto(@PathVariable String filename, 
                                          HttpServletRequest request) {
    
    // 路径遍历检测
    if (SecurityUtils.isPathTraversal(filename)) {
        throw new AccessDeniedException("非法文件访问");
    }
    
    // 文件访问权限检查
    String userId = getCurrentUserId(request);
    Photo photo = photoRepository.findByFilename(filename)
        .orElseThrow(() -> new FileNotFoundException("文件不存在"));
    
    if (!SecurityUtils.checkFileAccess(userId, photo.getUserId(), photo.isPublic())) {
        throw new AccessDeniedException("无权访问此文件");
    }
    
    // 继续处理下载...
}
```

### 文件上传安全

#### 1. 文件类型验证

```java
@Service
public class FileUploadService {
    
    private static final Set<String> ALLOWED_EXTENSIONS = Set.of(
        "jpg", "jpeg", "png", "gif", "bmp", "webp"
    );
    
    private static final Set<String> ALLOWED_MIME_TYPES = Set.of(
        "image/jpeg", "image/png", "image/gif", "image/bmp", "image/webp"
    );
    
    public void validateFile(MultipartFile file) {
        // 文件类型检查
        String originalFilename = file.getOriginalFilename();
        String extension = FilenameUtils.getExtension(originalFilename).toLowerCase();
        
        if (!ALLOWED_EXTENSIONS.contains(extension)) {
            throw new FileTypeException("不支持的文件类型");
        }
        
        // MIME类型检查
        String contentType = file.getContentType();
        if (!ALLOWED_MIME_TYPES.contains(contentType)) {
            throw new FileTypeException("不支持的文件类型");
        }
        
        // 文件大小检查
        if (file.getSize() > MAX_FILE_SIZE) {
            throw new FileSizeException("文件大小超过限制");
        }
    }
}
```

#### 2. 文件内容扫描

```java
@Service
public class FileScannerService {
    
    public void scanFileContent(MultipartFile file) {
        try {
            byte[] content = file.getBytes();
            
            // 检查可执行文件
            if (isExecutableFile(content)) {
                throw new FileException("禁止上传可执行文件");
            }
            
            // 检查恶意脚本
            if (containsMaliciousScript(content)) {
                throw new FileException("文件包含恶意内容");
            }
            
        } catch (IOException e) {
            throw new FileException("文件扫描失败");
        }
    }
    
    private boolean isExecutableFile(byte[] content) {
        // 检查PE文件头部
        if (content.length > 2 && 
            (content[0] == 'M' && content[1] == 'Z')) {
            return true;
        }
        
        // 检查ELF文件头部
        if (content.length > 4 && 
            (content[0] == 0x7F && content[1] == 'E' && 
             content[2] == 'L' && content[3] == 'F')) {
            return true;
        }
        
        return false;
    }
}
```

**段落来源**
- [SecurityUtils.java](file://src/main/java/com/photo/util/SecurityUtils.java#L115-L135)
- [PhotoController.java](file://src/main/java/com/photo/controller/PhotoController.java#L95-L105)

## 密钥和证书管理

### 密钥轮换策略

#### 1. 自动密钥轮换

```java
@Component
public class KeyRotationScheduler {
    
    @Scheduled(cron = "${security.token.rotation.cron:0 0 2 * * ?}")
    public void rotateKeys() {
        LocalDateTime now = LocalDateTime.now();
        Long lastRotation = securityProperties.getToken().getLastRotationTimestamp();
        
        if (lastRotation == null || 
            Duration.between(Instant.ofEpochMilli(lastRotation), now.toInstant(ZoneOffset.UTC))
                .toDays() >= securityProperties.getToken().getRotationIntervalDays()) {
            
            rotateJwtSecret();
            rotateEncryptionKey();
        }
    }
    
    private void rotateJwtSecret() {
        String newSecret = generateRandomSecret();
        securityProperties.getToken().setSecret(newSecret);
        securityProperties.getToken().setLastRotationTimestamp(System.currentTimeMillis());
        
        // 更新配置
        updateApplicationConfiguration();
        
        log.info("JWT密钥已轮换");
    }
}
```

#### 2. 证书管理

```bash
#!/bin/bash
# Let's Encrypt自动续期脚本

CERT_DIR="/etc/letsencrypt/live/yourdomain.com"
BACKUP_DIR="/backup/ssl-certs"

# 备份现有证书
cp -r $CERT_DIR $BACKUP_DIR/$(date +%Y%m%d_%H%M%S)

# 申请新证书
certbot certonly --standalone \
    -d yourdomain.com \
    -d www.yourdomain.com \
    --email admin@yourdomain.com \
    --agree-tos \
    --no-eff-email

# 重启应用
systemctl restart photo-upload-system

echo "SSL证书更新完成"
```

### 环境变量配置

```yaml
# application-prod.yml
security:
  token:
    secret: ${JWT_SECRET}
    expiration: ${JWT_EXPIRATION:86400}
  
server:
  ssl:
    enabled: ${SSL_ENABLED:true}
    key-store: ${SSL_KEYSTORE_PATH}
    key-store-password: ${SSL_KEYSTORE_PASSWORD}
    trust-store: ${SSL_TRUSTSTORE_PATH}
    trust-store-password: ${SSL_TRUSTSTORE_PASSWORD}
```

### 敏感信息加密

```java
@Component
public class EncryptionService {
    
    private final Cipher encryptCipher;
    private final Cipher decryptCipher;
    
    public EncryptionService() throws Exception {
        KeyGenerator keyGen = KeyGenerator.getInstance("AES");
        keyGen.init(256);
        SecretKey secretKey = keyGen.generateKey();
        
        encryptCipher = Cipher.getInstance("AES");
        decryptCipher = Cipher.getInstance("AES");
        
        encryptCipher.init(Cipher.ENCRYPT_MODE, secretKey);
        decryptCipher.init(Cipher.DECRYPT_MODE, secretKey);
    }
    
    public String encrypt(String data) throws Exception {
        byte[] encrypted = encryptCipher.doFinal(data.getBytes());
        return Base64.getEncoder().encodeToString(encrypted);
    }
    
    public String decrypt(String encryptedData) throws Exception {
        byte[] decoded = Base64.getDecoder().decode(encryptedData);
        byte[] decrypted = decryptCipher.doFinal(decoded);
        return new String(decrypted);
    }
}
```

**段落来源**
- [SecurityProperties.java](file://src/main/java/com/photo/config/SecurityProperties.java#L35-L40)
- [application.yml](file://src/main/resources/application.yml#L120-L125)

## 总结

本安全加固指南涵盖了Photo Upload System项目在生产环境中必须实施的关键安全措施：

### 核心安全要点

1. **JWT Token安全**：及时更换默认密钥，实施定期轮换策略
2. **传输层安全**：强制HTTPS加密，配置SSL/TLS证书
3. **网络访问控制**：配置防火墙规则，限制不必要的端口暴露
4. **跨域访问控制**：严格限制CORS策略，防止跨域攻击
5. **防盗链机制**：验证Referer头部，防止资源盗用
6. **Spring Security集成**：完善认证授权机制，启用CSRF保护
7. **多层攻击防护**：XSS、SQL注入、路径遍历等攻击防护
8. **密钥证书管理**：建立完善的密钥轮换和证书管理流程

### 安全监控建议

1. **日志监控**：记录所有安全相关事件
2. **入侵检测**：部署IDS/IPS系统
3. **性能监控**：监控异常流量模式
4. **合规审计**：定期进行安全审计

### 持续改进

1. **安全培训**：定期对开发团队进行安全培训
2. **漏洞扫描**：使用自动化工具定期扫描漏洞
3. **渗透测试**：定期进行专业渗透测试
4. **应急响应**：建立完善的安全事件响应机制

通过实施这些安全加固措施，可以显著提升Photo Upload System系统的安全性，有效防范各种常见的Web攻击，保护用户数据和系统资源。