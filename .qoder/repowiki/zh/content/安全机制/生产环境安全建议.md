# 生产环境安全加固指南

<cite>
**本文档引用的文件**
- [SecurityConfig.java](file://src/main/java/com/photo/config/SecurityConfig.java)
- [SecurityProperties.java](file://src/main/java/com/photo/config/SecurityProperties.java)
- [application.yml](file://src/main/resources/application.yml)
- [FileStorageProperties.java](file://src/main/java/com/photo/config/FileStorageProperties.java)
- [FileStorageService.java](file://src/main/java/com/photo/service/FileStorageService.java)
- [SecurityUtils.java](file://src/main/java/com/photo/util/SecurityUtils.java)
- [PhotoController.java](file://src/main/java/com/photo/controller/PhotoController.java)
- [README.md](file://README.md)
</cite>

## 目录
1. [概述](#概述)
2. [HTTPS传输加密](#https传输加密)
3. [身份认证与授权](#身份认证与授权)
4. [CORS安全配置](#cors安全配置)
5. [调试接口安全](#调试接口安全)
6. [文件上传安全](#文件上传安全)
7. [日志审计配置](#日志审计配置)
8. [其他安全建议](#其他安全建议)
9. [总结](#总结)

## 概述

本指南基于Photo Upload System项目的现有安全架构，针对生产环境提出了全面的安全加固建议。该系统提供了基础的文件上传下载功能，但在生产环境中需要额外的安全措施来保护数据传输、用户认证、文件处理和系统访问。

## HTTPS传输加密

### 必要性
在生产环境中，所有数据传输必须通过HTTPS进行加密，防止敏感信息在传输过程中被窃听或篡改。

### 实施方案

#### 1. 配置SSL证书
```yaml
# application.yml
server:
  ssl:
    enabled: true
    key-store-type: PKCS12
    key-store: classpath:keystore.p12
    key-store-password: your-keystore-password
    key-alias: your-alias
  port: 443
```

#### 2. 强制HTTPS重定向
```java
// 添加安全配置
@Bean
public SecurityFilterChain httpsFilterChain(HttpSecurity http) throws Exception {
    http.requiresChannel(channel -> 
        channel.anyRequest().requiresSecure());
    return http.build();
}
```

#### 3. HSTS配置
```yaml
# application.yml
server:
  http2:
    enabled: true
  compression:
    enabled: true
    mime-types: text/html,text/xml,text/plain,text/css,application/javascript,application/json,image/svg+xml
```

**段落来源**
- [SecurityConfig.java](file://src/main/java/com/photo/config/SecurityConfig.java#L20-L40)
- [application.yml](file://src/main/resources/application.yml#L150-L170)

## 身份认证与授权

### 当前问题分析
当前的SecurityConfig使用了`permitAll()`策略，这在生产环境中存在安全隐患，可能导致未授权访问。

### 改进方案

#### 1. 替换permitAll为JWT认证
```java
// 修改SecurityConfig
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http
        .csrf(csrf -> csrf.disable())
        .cors(cors -> cors.configurationSource(corsConfigurationSource()))
        .sessionManagement(session -> 
            session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
        .authorizeHttpRequests(auth -> auth
            .requestMatchers(
                "/h2-console/**",
                "/api-docs/**",
                "/swagger-ui/**",
                "/swagger-ui.html",
                "/photos/view/**",
                "/photos/download/**",
                "/photos/public/**"
            ).permitAll()
            .anyRequest().authenticated()  // 所有其他请求都需要认证
        )
        .addFilter(new JwtAuthenticationFilter(authenticationManager(http)))
        .addFilter(new JwtAuthorizationFilter(authenticationManager(http)));
    
    return http.build();
}
```

#### 2. JWT配置优化
```yaml
# application.yml
security:
  jwt:
    secret: ${JWT_SECRET:your-generated-jwt-secret-key}
    expiration: 86400000  # 24小时
    refresh-token-expiration: 604800000  # 7天
  referer:
    enabled: true
    allowed-domains:
      - https://yourdomain.com
      - https://www.yourdomain.com
```

#### 3. 实现JWT工具类
```java
@Component
public class JwtUtil {
    
    @Value("${security.jwt.secret}")
    private String secret;
    
    @Value("${security.jwt.expiration}")
    private long expiration;
    
    public String generateToken(String username) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + expiration);
        
        return Jwts.builder()
            .setSubject(username)
            .setIssuedAt(now)
            .setExpiration(expiryDate)
            .signWith(SignatureAlgorithm.HS512, secret)
            .compact();
    }
    
    public Claims parseToken(String token) {
        return Jwts.parser()
            .setSigningKey(secret)
            .parseClaimsJws(token)
            .getBody();
    }
}
```

**段落来源**
- [SecurityConfig.java](file://src/main/java/com/photo/config/SecurityConfig.java#L25-L40)
- [SecurityProperties.java](file://src/main/java/com/photo/config/SecurityProperties.java#L25-L45)

## CORS安全配置

### 当前配置问题
当前的CORS配置虽然启用了，但允许所有头部和凭据，可能存在安全风险。

### 安全配置建议

#### 1. 严格限制CORS配置
```yaml
# application.yml
security:
  cors:
    enabled: true
    allowed-origins:
      - https://yourdomain.com
      - https://www.yourdomain.com
      - https://app.yourdomain.com
    allowed-methods:
      - GET
      - POST
      - PUT
      - DELETE
      - OPTIONS
    allowed-headers:
      - Authorization
      - Content-Type
      - X-Requested-With
    allow-credentials: true
```

#### 2. 动态CORS配置
```java
@Bean
public CorsConfigurationSource corsConfigurationSource() {
    CorsConfiguration configuration = new CorsConfiguration();
    
    if (securityProperties.getCors().getEnabled()) {
        configuration.setAllowedOrigins(securityProperties.getCors().getAllowedOrigins());
        configuration.setAllowedMethods(securityProperties.getCors().getAllowedMethods());
        
        // 限制允许的头部
        List<String> allowedHeaders = securityProperties.getCors().getAllowedHeaders();
        if (allowedHeaders == null || allowedHeaders.isEmpty()) {
            configuration.setAllowedHeaders(Arrays.asList(
                "Authorization", "Content-Type", "X-Requested-With"));
        } else {
            configuration.setAllowedHeaders(allowedHeaders);
        }
        
        configuration.setAllowCredentials(securityProperties.getCors().getAllowCredentials());
        configuration.setMaxAge(3600L);
    }
    
    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
    source.registerCorsConfiguration("/**", configuration);
    return source;
}
```

**段落来源**
- [SecurityConfig.java](file://src/main/java/com/photo/config/SecurityConfig.java#L42-L55)
- [SecurityProperties.java](file://src/main/java/com/photo/config/SecurityProperties.java#L35-L45)

## 调试接口安全

### H2控制台风险
H2控制台在生产环境中应该完全禁用，因为它提供了对数据库的直接访问。

### 安全措施

#### 1. 禁用H2控制台
```yaml
# application.yml
spring:
  h2:
    console:
      enabled: false
      path: /h2-console
```

#### 2. 禁用其他调试接口
```yaml
# application.yml
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics
        exclude: beans,mappings,env
  endpoint:
    health:
      show-details: never
```

#### 3. 移除开发环境专用配置
```yaml
# 移除或注释掉以下配置
# spring:
#   jpa:
#     show-sql: true
#     properties:
#       hibernate:
#         format_sql: true
```

**段落来源**
- [application.yml](file://src/main/resources/application.yml#L30-L40)
- [application.yml](file://src/main/resources/application.yml#L155-L165)

## 文件上传安全

### 当前安全措施
系统已经实现了基本的文件类型和大小限制，但仍需加强安全防护。

### 加强措施

#### 1. 严格文件类型验证
```java
// FileStorageService.java - 增强文件类型验证
public String storeFile(MultipartFile file) {
    // 验证文件名
    String originalFilename = file.getOriginalFilename();
    if (!FileUtils.isValidFilename(originalFilename)) {
        throw new FileStorageException("文件名包含非法字符: " + originalFilename);
    }
    
    // 严格验证文件类型
    String contentType = file.getContentType();
    if (!storageProperties.getAllowedTypes().contains(contentType)) {
        throw new FileTypeException("不支持的文件类型: " + contentType);
    }
    
    // 使用Apache Tika进行深度文件类型检测
    try (InputStream inputStream = file.getInputStream()) {
        Tika tika = new Tika();
        String detectedType = tika.detect(inputStream);
        if (!storageProperties.getAllowedTypes().contains(detectedType)) {
            throw new FileTypeException("文件类型检测失败: " + detectedType);
        }
    } catch (IOException e) {
        throw new FileStorageException("文件类型检测失败", e);
    }
    
    // 其他验证逻辑...
}
```

#### 2. 严格的文件大小限制
```yaml
# application.yml
file:
  storage:
    max-file-size: 5242880  # 5MB
    max-files-per-upload: 5  # 最多上传5个文件
    max-storage-size: 5368709120  # 5GB
```

#### 3. 文件上传频率限制
```java
@Component
public class RateLimitInterceptor implements HandlerInterceptor {
    
    private final Map<String, AtomicInteger> requestCounts = new ConcurrentHashMap<>();
    private final long timeWindowMillis = 60000; // 1分钟
    
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
        String clientIp = SecurityUtils.getClientIpAddress(request);
        String key = clientIp + ":" + request.getRequestURI();
        
        long currentTime = System.currentTimeMillis();
        AtomicInteger count = requestCounts.computeIfAbsent(key, k -> new AtomicInteger(0));
        
        // 清理过期计数
        requestCounts.entrySet().removeIf(entry -> 
            currentTime - entry.getKey().split(":")[1].longValue() > timeWindowMillis);
        
        // 检查频率限制
        if (count.incrementAndGet() > 100) { // 1分钟内最多100次请求
            throw new RateLimitException("请求过于频繁，请稍后再试");
        }
        
        return true;
    }
}
```

#### 4. 文件内容扫描
```java
@Component
public class FileContentScanner {
    
    public void scanFileContent(File file) {
        try (InputStream inputStream = new FileInputStream(file)) {
            // 检测恶意脚本
            Scanner scanner = new Scanner(inputStream);
            while (scanner.hasNextLine()) {
                String line = scanner.nextLine().toLowerCase();
                if (line.contains("<script>") || 
                    line.contains("javascript:") || 
                    line.contains("data:text/html")) {
                    throw new SecurityException("文件包含恶意脚本内容");
                }
            }
            
            // 检测二进制文件中的HTML标记
            inputStream.reset();
            byte[] buffer = new byte[1024];
            int bytesRead;
            while ((bytesRead = inputStream.read(buffer)) != -1) {
                String content = new String(buffer, 0, bytesRead);
                if (content.contains("<html") || content.contains("<body")) {
                    throw new SecurityException("检测到嵌入的HTML内容");
                }
            }
        } catch (IOException e) {
            throw new SecurityException("文件扫描失败", e);
        }
    }
}
```

**段落来源**
- [FileStorageService.java](file://src/main/java/com/photo/service/FileStorageService.java#L50-L80)
- [FileStorageProperties.java](file://src/main/java/com/photo/config/FileStorageProperties.java#L35-L50)

## 日志审计配置

### 当前日志级别
系统使用DEBUG级别日志，生产环境中应调整为更安全的日志级别。

### 审计配置

#### 1. 生产环境日志配置
```yaml
# application.yml
logging:
  level:
    root: WARN
    com.photo: INFO
    org.springframework.security: INFO
    org.springframework.web: ERROR
    org.hibernate: ERROR
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n"
    file: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n"
  file:
    name: ./logs/photo-upload-system.log
    max-size: 50MB
    max-history: 30
    total-size-cap: 1GB
```

#### 2. 安全事件审计
```java
@Component
public class SecurityEventLogger {
    
    private static final Logger auditLogger = LoggerFactory.getLogger("SECURITY_AUDIT");
    
    public void logLoginAttempt(String username, String ipAddress, boolean success) {
        auditLogger.info("LOGIN_ATTEMPT | username={} | ip={} | success={} | timestamp={}",
            username, ipAddress, success, LocalDateTime.now());
    }
    
    public void logFileUpload(String username, String filename, String ipAddress, long fileSize) {
        auditLogger.info("FILE_UPLOAD | username={} | filename={} | ip={} | size={} | timestamp={}",
            username, filename, ipAddress, fileSize, LocalDateTime.now());
    }
    
    public void logUnauthorizedAccess(String resource, String ipAddress) {
        auditLogger.warn("UNAUTHORIZED_ACCESS | resource={} | ip={} | timestamp={}",
            resource, ipAddress, LocalDateTime.now());
    }
    
    public void logSecurityViolation(String violationType, String details, String ipAddress) {
        auditLogger.error("SECURITY_VIOLATION | type={} | details={} | ip={} | timestamp={}",
            violationType, details, ipAddress, LocalDateTime.now());
    }
}
```

#### 3. 请求追踪中间件
```java
@Component
public class RequestTraceInterceptor implements HandlerInterceptor {
    
    private static final ThreadLocal<Map<String, Object>> requestContext = new ThreadLocal<>();
    
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
        Map<String, Object> context = new HashMap<>();
        context.put("requestId", UUID.randomUUID().toString());
        context.put("startTime", System.currentTimeMillis());
        context.put("ipAddress", SecurityUtils.getClientIpAddress(request));
        context.put("uri", request.getRequestURI());
        context.put("method", request.getMethod());
        
        requestContext.set(context);
        
        log.info("REQUEST_START | requestId={} | uri={} | method={} | ip={}",
            context.get("requestId"), context.get("uri"), context.get("method"), context.get("ipAddress"));
        
        return true;
    }
    
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, 
                               Object handler, Exception ex) {
        Map<String, Object> context = requestContext.get();
        if (context != null) {
            long duration = System.currentTimeMillis() - (Long) context.get("startTime");
            
            log.info("REQUEST_END | requestId={} | duration={}ms | status={} | uri={}",
                context.get("requestId"), duration, response.getStatus(), context.get("uri"));
            
            requestContext.remove();
        }
    }
}
```

**段落来源**
- [application.yml](file://src/main/resources/application.yml#L130-L150)
- [PhotoController.java](file://src/main/java/com/photo/controller/PhotoController.java#L40-L50)

## 其他安全建议

### 1. 数据库安全
```yaml
# application.yml
spring:
  datasource:
    hikari:
      maximum-pool-size: 10
      minimum-idle: 5
      idle-timeout: 30000
      connection-timeout: 20000
      leak-detection-threshold: 60000
    validation-query: SELECT 1
    test-on-borrow: true
    test-while-idle: true
```

### 2. 缓存安全
```yaml
# application.yml
spring:
  cache:
    type: redis
    redis:
      host: localhost
      port: 6379
      timeout: 5000ms
      lettuce:
        pool:
          max-active: 8
          max-idle: 8
          min-idle: 0
```

### 3. 系统监控
```yaml
# application.yml
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
  endpoint:
    health:
      show-details: when-authorized
  metrics:
    export:
      prometheus:
        enabled: true
```

### 4. 防止暴力破解
```java
@Component
public class BruteForceProtection {
    
    private final Map<String, LoginAttemptTracker> attemptTrackers = new ConcurrentHashMap<>();
    
    public boolean isBlocked(String username, String ipAddress) {
        String key = username + ":" + ipAddress;
        LoginAttemptTracker tracker = attemptTrackers.computeIfAbsent(key, k -> new LoginAttemptTracker());
        
        return tracker.isBlocked();
    }
    
    public void recordAttempt(String username, String ipAddress, boolean success) {
        String key = username + ":" + ipAddress;
        LoginAttemptTracker tracker = attemptTrackers.computeIfAbsent(key, k -> new LoginAttemptTracker());
        
        if (!success) {
            tracker.recordFailedAttempt();
        } else {
            tracker.reset();
        }
    }
    
    private static class LoginAttemptTracker {
        private int failedAttempts = 0;
        private long lastAttemptTime = 0;
        
        public void recordFailedAttempt() {
            long currentTime = System.currentTimeMillis();
            if (currentTime - lastAttemptTime > 3600000) { // 1小时内
                failedAttempts = 1;
            } else {
                failedAttempts++;
            }
            lastAttemptTime = currentTime;
        }
        
        public boolean isBlocked() {
            return failedAttempts >= 5;
        }
        
        public void reset() {
            failedAttempts = 0;
        }
    }
}
```

### 5. 输入验证增强
```java
// SecurityUtils.java - 增强输入验证
public static String sanitizeInput(String input) {
    if (!StringUtils.hasText(input)) {
        return null;
    }
    
    // 移除危险字符
    String sanitized = input.replaceAll("[<>\"']", "");
    
    // 防止SQL注入
    String[] sqlInjectionPatterns = {
        "(?i)union\\s+select",
        "(?i)drop\\s+table",
        "(?i)insert\\s+into",
        "(?i)delete\\s+from",
        "(?i)create\\s+table",
        "(?i)alter\\s+table",
        "(?i)exec\\s+\\w*",
        "(?i)declare\\s+\\w*",
        "--", "\\*/", "/\\*"
    };
    
    for (String pattern : sqlInjectionPatterns) {
        sanitized = sanitized.replaceAll(pattern, "");
    }
    
    return sanitized.trim();
}
```

## 总结

本生产环境安全加固指南涵盖了以下关键安全领域：

1. **传输安全**：强制HTTPS加密传输，防止数据泄露
2. **身份认证**：从简单的permitAll策略升级为JWT认证机制
3. **访问控制**：严格配置CORS策略，限制跨域访问
4. **调试安全**：禁用H2控制台和其他调试接口
5. **文件安全**：实施严格的文件类型、大小和内容验证
6. **审计监控**：建立完善的安全事件审计和日志系统

这些措施能够显著提升系统的安全性，保护用户数据和系统资源免受各种网络威胁。建议在实施过程中进行充分的测试，并持续监控系统安全状态。